{
  "name": "queue-flow",
  "description": "Chainable logic built on named (or not) queues for Javascript and Node.js",
  "keywords": [
    "queue-flow",
    "queueflow",
    "flow",
    "queues",
    "async"
  ],
  "homepage": "http://dfellis.github.com/queue-flow",
  "author": {
    "name": "David Ellis"
  },
  "version": "0.6.20",
  "bugs": {
    "url": "https://github.com/dfellis/queue-flow/issues"
  },
  "repository": {
    "type": "git",
    "url": "git://github.com:dfellis/queue-flow.git"
  },
  "main": "./lib/queue-flow",
  "dependencies": {
    "is-async": "0.0.2",
    "async-cancelable-events": "0.0.6"
  },
  "devDependencies": {
    "nodeunit": "*",
    "docco": "*",
    "browserify": "*",
    "uglify-js": "*",
    "jscoverage": "https://github.com/dfellis/jscoverage/archive/master.tar.gz",
    "complexity-report": "*",
    "jshint": "*",
    "tape": "*",
    "coveralls": "*"
  },
  "engines": {
    "node": ">=0.6"
  },
  "scripts": {
    "realpublish": "./prepublish.sh && npm publish",
    "test": "npm run jshint && nodeunit ./test/test-node.js && npm run testperf",
    "testbrowser": "tape ./test/test-browser.js",
    "testperf": "nodeunit ./test/test-perf.js",
    "jshint": "./test/jshint.sh"
  },
  "testling": {
    "files": "test/test-browser.js",
    "browsers": {
      "ie": [
        9,
        10
      ],
      "firefox": [
        14,
        15,
        16,
        17,
        "nightly"
      ],
      "chrome": [
        20,
        21,
        22,
        23,
        "canary"
      ],
      "safari": [
        6
      ],
      "opera": [
        11,
        "11.6",
        12,
        "next"
      ],
      "iphone": [
        6
      ],
      "ipad": [
        6
      ]
    }
  },
  "readme": "# [![queue-flow](http://dfellis.github.com/queue-flow/images/queue-flow-logo.svg)](http://dfellis.github.com/queue-flow)\n\n[![NPM version](https://badge.fury.io/js/queue-flow.png)](http://badge.fury.io/js/queue-flow) [![Build Status](https://secure.travis-ci.org/dfellis/queue-flow.png)](http://travis-ci.org/dfellis/queue-flow) [![Dependency Status](https://gemnasium.com/dfellis/queue-flow.png)](https://gemnasium.com/dfellis/queue-flow) [![Coverage Status](https://coveralls.io/repos/dfellis/queue-flow/badge.png?branch=master)](https://coveralls.io/r/dfellis/queue-flow?branch=master)\n\n[![browser support](http://ci.testling.com/dfellis/queue-flow.png)](http://ci.testling.com/dfellis/queue-flow)\n\n## Quick install instructions\n\nFor Node.js\n\n    npm install queue-flow\n\nFor browsers, just copy ``./lib/queue-flow.min.js`` (generated by [UglifyJS](https://github.com/mishoo/UglifyJS/))and include it in a ``<script>`` tag.\n\nFor developers, ``npm test`` to check your changes (using [nodeunit](https://github.com/caolan/nodeunit/)) haven't broken existing functionality.\n\n## Easy-to-follow data processing with queues, flowcharts, and functional programming\n\nTired of this?\n\n```js\nstuck(arg, function(err, result) {\n    if(err) return console.log(err);\n    In(result, function(err, result) {\n        if(err) return console.log(err);\n        callback(result, function(err, result) {\n            if(err) return console.log(err);\n            hell(result);\n        });\n    });\n});\n```\n\n(\"stuck in callback hell\")\n\nWhat if you could write it like this?\n\n```js\nq([arg])\n    .node(notStuck, 'error')\n    .node(In, 'error')\n    .node(callback, 'error')\n    .each(hell);\nq('error')\n    .each(console.log);\n```\n\nTired of this?\n\n```js\nasync.waterfall([\n    dealing.bind(this, arg),\n    function With(result, callback) {\n        if(result.foo == 'branch1') {\n            async.waterfall([\n                nested.bind(this, result),\n                branches\n            ], callback);\n        } else {\n            async.waterfall([\n                making.bind(this, result),\n                code,\n                difficult\n            ], callback);\n        }\n    },\n    to.bind(this, 'const1', 'const2')\n], function(err, result) {\n    if(err) return console.log(err);\n    follow(result);\n});\n```\n\n(\"dealing with nested branches making code difficult to follow\")\n\nWhat if you could write it like this?\n\n```js\nq([arg])\n    .node(dealing, 'error')\n    .branch(function With(result) {\n        return result.foo == 'branch1' ? 'branch1' : 'branch2';\n    });\nq('branch1')\n    .node(nested, 'error')\n    .node(branches, 'error')\n    .chain('branchesRejoined');\nq('branch2')\n    .node(making, 'error')\n    .node(code, 'error')\n    .node(easy, 'error')\n    .chain('branchesRejoined');\nq('branchesRejoined')\n    .node(to.bind(this, 'const1', 'const2'), 'error');\n    .each(follow);\nq('error')\n    .each(console.log);\n```\n\nTired of this?\n\n```js\nsomeRemoteCall('arg', function recursing(err, result) {\n    if(err) return console.log(err);\n    if(result == 'good') {\n        doSomethingElse();\n    } else {\n        someRemoteCall(result, recursing);\n        // Arg! Stack Overflow!?\n        // But I can't unroll this recursion because it's an async function, right?\n    }\n});\n```\n\nHow about this?\n\n```js\nq('recursiveCall')\n    .node(someRemoteCall, 'error')\n    .branch(function(result) {\n        return result == 'good' ? 'doSomethingElse' : 'recursiveCall';\n    }); // Cannot blow the stack!\nq('error')\n    .each(console.log);\nq('doSomethingElse')\n    ...\n```\n\n``queue-flow`` makes async and sync data processing code easy to read like ``Fibers`` (it doesn't look like fibers code, but it is easy to follow like it) while not altering the Javascript language itself like ``async``, giving you the best of both worlds, along with some other advantages:\n\n* queues in ``queue-flow`` are simply temporary storage for the consuming method \"verb\" you use. These \"verbs\" create new, anonymous queues so they can be chained together easily for a terse, easy-to-understand syntax.\n* Because there are anonymous queues in between, as one \"verb\" completes its task on one item to process, it can pass that along to the next \"verb\" in the chain to process while it starts to tackle the next item. If most of your \"verbs\" are dealing with I/O (database, file system, network connection, etc), then you very quickly will keep all of the other processes in your \"pipeline\" saturated, while still guaranteeing First-In-First-Out.\n* Don't want that guarantee that the first request in is the first response out (such as for serving web pages?) ``queue-flow`` allows its constructor function to be overridden, and [sloppy-queue-flow](https://github.com/dfellis/sloppy-queue-flow) breaks queue order, turning your queue into essentially a task list of operations to perform on independent data.\n* Named queues, ``branch``, and ``chain`` allow you to turn your queues into a flowchart of actions to perform, allowing you to organize your async tasks in easy-to-understand chunks just as functions organize imperative code in easy-to-reuse chunks, and all imperative constructs (``if, while, for``) can be replicated with ``branch``.\n\nStill not convinced? [Check out more examples on why ``queue-flow`` is better than ``async``.](http://dfellis.github.com/queue-flow/2012/09/22/why-queue-flow/)\n\nWant to learn more? [Check out the tutorial for ``queue-flow``](http://dfellis.github.com/queue-flow/2012/09/21/tutorial/) with neat figures explaining the behavior of ``queue-flow`` and its many method verbs. After that, you can [read the annotated source code, yourself](http://dfellis.github.com/queue-flow/docs/queue-flow.html), which is updated right when new releases of ``queue-flow`` are published (see the nifty [prepublish script](https://github.com/dfellis/queue-flow/blob/master/prepublish.sh)). (If youre just looking for an API reference, just read the left-hand column and ignore the source code on the right.)\n\n## License (MIT)\n\nCopyright (C) 2012-2013 by David Ellis\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n",
  "readmeFilename": "readme.md",
  "_id": "queue-flow@0.6.20",
  "dist": {
    "shasum": "6cfa9c0c0482370de443788a423777d53887df70",
    "tarball": "http://registry.npmjs.org/queue-flow/-/queue-flow-0.6.20.tgz"
  },
  "_from": "queue-flow@<0.7.x",
  "_npmVersion": "1.3.8",
  "_npmUser": {
    "name": "dfellis",
    "email": "d.f.ellis@ieee.org"
  },
  "maintainers": [
    {
      "name": "dfellis",
      "email": "d.f.ellis@ieee.org"
    }
  ],
  "directories": {},
  "_shasum": "6cfa9c0c0482370de443788a423777d53887df70",
  "_resolved": "https://registry.npmjs.org/queue-flow/-/queue-flow-0.6.20.tgz"
}
